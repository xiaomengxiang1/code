//----------------算数操作符-------------------


//----------------左右移位操作符-------------------


// 整数的2进制表示有3种
//原码
//反码
//补码

//正整数3个相同
//负整数的3个要计算

//7
//00000000 00000000 00000000 00000111 - 原码
//00000000 00000000 00000000 00000111 - 反码
//00000000 00000000 00000000 00000111 - 补码

//-7
//10000000 00000000 00000000 00000111 - 原码
//11111111 11111111 11111111 11111000 - 反码(原码的符号不变,其他位按位取反就是反码)
//11111111 11111111 11111111 11111001 - 补码(反码 + 1 就是补码)
//
//整数在内存中存储的是补码
//

// 移位操作符移动的是补码
// << 左移操作符
// 补码左移    左边抛弃右边补0
// #include <stdio.h>
// int main() {

//     int a = 7;

//     int b = a << 1;

//     printf("b = %d\n", b);
//     printf("a = %d\n", a);
    
//     return 0;
// }

// 左移乘二，右移除二(向下取整)
// x << n 相当于 x * (2^n)
// x >> 1 相当于 x / 2（向下取整），x >> n 相当于 x / (2^n)

// >> 右移操作符

// 算数移位(常用)
// 补码右移    右边抛弃左边补原来的符号

// 逻辑移位
// 右边抛弃左边补0

// #include <stdio.h>
// int main() {

//     int a = -5;

//     int b = a >> 1;

//     printf("%d", b);
    
//     return 0;
// }


//----------------与或异或-------------------

//只能整数
// &    按位(二进制)与  只有当两个对应的位都为 1 时，结果才为 1，否则为 0
// |    按位(二进制)或  只要其中一个位为 1，结果就为 1，只有两个位都为 0，结果才为 0
// ^    按位(二进制)异或    相同的位得 0，不同的位得 1
// ~    按位取反

// a ^ a = 0;
// 0 ^ a = a;
// 支持交换律

//  a = a ^ b;
//  b = a ^ b; //b = a ^ b ^ b = a
//  a = a ^ b; //a = a ^ a ^ b = b






//----------------指针-------------------

// 内存单元(1byte)
// 内存单元的编号就成称为地址(地址也叫指针)
// 指针就是内存单元的编号

// #include <stdio.h>
// int main () {
//     int a = 10;
//     // 四个内存单元，4字节， &a 取出的是第一个单元的地址编号

//     int* pa = &a;

//     int b = sizeof(pa);

//     printf("%d", b);
//     //  8 byte


//     return 0;
// }

// 32位机器 32根地址线
// 高电平为1，低电平为0
// 00000000 00000000 00000000 00000000
// ......................
// 11111111 11111111 11111111 11111111

// 一个二进制序列代表一个地址,一个地址1 byte
// 1byte

// 2^32 byte == 4gb 

// 内存单元不是地址，大小为1个字节·，内存单元的编号是地址，大小取决于是32位（4字节），是64位（8字节）
// 指针大小在32位平台上是4字节 64位上是8字节


// 指针类型决定解引用操作访问的是几个字节
// 十六进制
// 0*006FF9F8
// 0*006FF9F9

// 相差0*1 一个字节

// 指针的类型决定解引用时访问几个字节
// 只跟指向的类型有关，因为是指针指向下一个元素
// 指针的类型决定指针+-1操作,跳过几个字节

//----------------野指针-------------------
// 指针越界也会造成野指针出现
// int main () {
//     int* p;//局部指针变量未初始化，指向随机值

//     *p = 20;

//     return 0;
// }

//----------------指针运算------------------
// 低                      高
// ----------------------->
// 数组的内存高低比较

// #define N_VALUES 5
// int main() {

//     float values[N_VALUES];
//     float* vp;
//     // 这里不会数组越界,因为只是看一下地址,没有对其内容操作
//     for (vp = &values[0]; vp < &values[N_VALUES]) {
//         // ++优先级比赋值更高,先使用后置++,后赋值
//         // 相当于*vp = 0;
//         //       vp++;
//         *vp++ = 0;

//     }
// }

// 指针+-整数=指针
// 指针-指针=整数
// |指针-指针|得到的是指针和指针之间的元素个数

// 指针-指针版本
// #include <stdio.h>
// int my_strlen(char* str) {
//     char* start = str;
//     while (*str != '\0') {
//         str++;
//     }

//     return str - start;
// }

// int main() {
//     //不要直接char str = "abcedf";  因为char不能直接储存字符串
//     char str[] = "abcdef";
//     int len = my_strlen(str);
//     printf("%d\n", len);
//     return 0;
// }

// 允许数组元素的指针与指向数组元素最后一个元素后面的哪个内存位置的指针比较，
// 相反不能和第一个元素的前一个内存位置的指针比较

// 指针访问数组
// #include <stdio.h>
// int main() {
//     int arr[10] = {0};
//     int i = 0;

//     int* p = arr;
//     int sz = sizeof(arr) / sizeof(arr[0]);

//     for (i = 0; i < sz; i++) {
//         printf("%d ", *(p + i));
//     }
//     printf("\n");

//     //&arr[i], p + i地址相同
//     for (i = 0; i < sz; i++) {
//         printf("%p--------%p\n", &arr[i], p + i);
//     }

//     return 0;
// }


//----------------二级指针------------------
// #include <stdio.h>

// int main() {
//     int a = 10;
//     int* pa = &a;//pa是一个指针变量,一级指针变量
//     int** ppa = &pa;//ppa是一个二级指针变量

//     **ppa = 20;//解引用两次

//     printf("%d", a);

//     return 0;
// }

//----------------指针数组------------------
// 存放指针的数组
// #include <stdio.h>
// int main() {
//     int a = 10;
//     int b = 20;
//     int c = 30;

//     int* pa = &a;
//     int* pb = &b;
//     int* pc = &c;

//     int* parr[10] = {&a, &b, &c};
//     int i = 0;
//     for (i = 0; i < 3; i++) {
//         printf("%d\n", *(parr[i]));
//     }
//     return 0;
// }

// 指针表示二维数组
// #include <stdio.h>
// int main() {
//     int arr1[4] = {1,2,3,4}; 
//     int arr2[4] = {2,3,4,5}; 
//     int arr3[4] = {3,4,5,6}; 

//     int* parr[3] = {arr1, arr2, arr3};
//     int i = 0;
//     for (i = 0; i < 3; i++) {
//         int j = 0;

//         //parr[i]就相当于arr1,arr2,arr3
//         for (j = 0; j < 4; j++) {
//             printf("%d ", parr[i][j]);
//         }
//         printf("\n");
//     }
// }


// parr[i][j],
// i是parr这个指针数组的索引，共三个，
// 而[j]是通过指针数组索引后解析出来的数组的索引，共四个


//----------------结构体------------------
// 一些值的集合，可以是不同的类型

// 结构体的声明
// 结构体相当于创建了结构体类型
// 声明结构体并不会占空间
// 创建结构体变量时才会向内存申请空间
// #include <stdio.h>
// struct Peo {
//     char name[20];
//     char sex[5];
//     char tele[12];
//     int high;
// };

// struct St {
//     struct Peo p;
//     int num;
//     float f;
// };


// void print1(struct Peo* sp) {

//     printf("%s %s %s %d\n", sp->name, sp->sex, sp->tele, sp->high);//结构体指针->成员变量
// }

// void print2(struct Peo p) {

//     printf("%s %s %s %d\n", p.name, p.sex, p.tele, p.high);//结构体变量.成员变量
// }

// int main() {

//     struct  Peo p1 = {"张三", "男", "123454677", 181};//结构体变量的创建
//     //结构体的嵌套
//     struct St s = {{"张三", "男", "123454677", 181}, 12, 1.0};

//     printf("%s %s %s %d\n", p1.name, p1.sex, p1.tele, p1.high);
//     printf("%s %s %s %d %d %f\n", s.p.name, s.p.sex, s.p.tele, s.p.high, s.num, s.f);

//     print1(&p1);
//     print2(p1);

//     return 0;
// }

//结构体传递参数尽量传递地址
// 函数传递参数要进行压栈
// 参数较大系统的负担较大

// 函数栈帧（stack frame）就是函数调用过程中在程序的调用栈（call stack）所开辟的空间，这些空间是用来存放

// 函数参数和函数返回值
// 临时变量（包括函数的非静态的局部变量以及编译器自动生产的其他临时变量）
// 保存上下文信息（包括在函数调用前后需要保持不变的寄存器）


// 栈被定义为一种特殊的容器，
// 用户可以将数据压入栈中（入栈，push），
// 也可以将已经压入栈中的数据弹出（出栈，pop），
// 但是栈这个容器必须遵守一条规则：先入栈的数据后出栈（First In Last Out， FILO）

// 栈总是向下增长（由高地址向低地址）的

//const
// #include <stdio.h>
// int main() {
//     const int num = 10;
//     //const修饰指针变量
//     //1. const放在*的左边
//     //修饰的是*p指向的对象,不能通过p来改变,p本身的值可以改变
//     // const int* p = &num;
//     //*p = 20; //err

//     //2. const放在*右边
//     //p指向的对象可以通过p来改变,但是不能修改p本身的值
//     //p = &n; //err
//     //*p = 0; //right
//     const int* p = &num;


// }

//my_strlen完整版
// #include <stdio.h>
// #include <assert.h>
// //防止函数内部修改传入的参数
// int my_strlen(const char* str) {
//     int count = 0;

//     //若str为空指针,即为0,则抛出错误
//     assert(str);
//     while (*str) {
//         str++;
//         count++;
//     }
//     return count;
// }
// int main() {

//     char arr[] = "hello";
//     printf("%d\n", my_strlen(arr));
//     return 0;
// }