// -------------------数据存储-----------------

//整数的2进制表示也有三种表示形式：

//1.正的整数，原码、反码、补码相同
//2.负的整数，原码、反码、补码是需要计算的
//原码：直接通过正负的形式写出的二进制序列就是原码
//反码：原码的符号位不变，其他位按位取法得到的就是反码
//补码：反码+1就是补码


//  高位      低位
// 0x11 22 33 44
// ---------------------------------------->
// 地地址                              高地址

// 大端【字节序】存储：
// 把一个数据的高位字节序的内容存放在低地址处，把低位字节序的内容放在高地址处，就是大端字节序存储。

// 小端【字节序】存储：
// 把一个数据的高位字节序的内容存放在高地址处，把低位字节序的内容放在低地址处，就是小端字节序存储。

//判断设备存放数据模式(大小端)
// #include <stdio.h>
// int check_sys() {
//     int a = 1;
//     //0x00 00 00 01

//     //01 00 00 00
//     //0000 0001
//     char* p = (char*)&a;
//     if (*p == 1) {
//         return 1;
//     }
//     else {
//         return 0;
//     }
// }
// int main() {
//     int ret = check_sys();
//     if (ret == 1) {
//         printf("小端存储\n");
//     }
//     else {
//         printf("大端存储\n");
//     }
//     return 0;
// }


// -------------------整型提升-----------------
// 补码中进行

// 负数的整形提升
// char c1=-1;
// 变量c1的二进制位（补码）中只有8个比特位：1111111
// 因为 char 为有符号的char
// 所以整形提升的时候，高位补充符号位，即为1提升之后的结果是：
// 11111111111111111111111111111111 

//正数的整形提升
// char c2 1;
// 变量c2的二进制位（补码）中只有8个比特位：00000001
// 因为 char 为有符号的 char
// 所以整形提升的时候，高位补充符号位，即为0提升之后的结果是：
// 0000000000000000000000000001 

//无符号整形提升，高位补0

// #include <stdio.h>
// int main() {
//     char a = 5;
//     // 补码截断存储:
//     // 00000101

//     char b = 125;
//     // 补码截断存储:
//     // 01111101

//     char c = a + b;
//     //计算时整型提升
//     //补符号位
//     // 00000000 00000000 00000000 00000101 - a
//     // 00000000 00000000 00000000 01111101 - b
//     // 相加
//     // 00000000 00000000 00000000 10000011 - c
//     //截断存储  这里是负数，所以对应补码
//     // 10000011 - c
//     //负数
//     //打印出整数也要进行整形提升
//     //补符号位
//     // 11111111 11111111 11111111 10000011 - c 补码
//     //按位取反 + 1
//     // 10000000 00000000 00000000 01111101 - c 源码 //-125

//     printf("%d\n", c);
//     return 0;
// }

// #include <stdio.h>
// int main() {
//     char a = 0xb6;
//     short b = 0xb600;
//     int c = 0xb6000000;


//     //只打印a 表达式中会发生整型提升
//     if (a == 0xb6) {
//         printf("a\n");
//     }

//     if (b == 0xb60) {
//         printf("b\n");
//     }

//     if (c == 0xb6000000) {
//         printf("c\n");
//     }
//     return 0;
// }

// -------------------算数转换-----------------
// 向上转换
// long double
// double
// float
// unsigned long int
// long int
// unsigned int
// int

// #include <stdio.h>
// int main() {
//     int a = -1;
//     unsigned int b = 3;

//     // int a = -1;                // 二进制为 0xFFFFFFFF（补码）
//     // unsigned int b = 3;

//     // a  -> 被提升为 unsigned int，也就是 0xFFFFFFFF == 4294967295
//     // b  -> 3

//     // a + b = 4294967295 + 3 = 4294967298
//     // 4294967298 % (2^32) = 2


//     printf("%u\n", a + b);
//     return 0;
// }

// 有符号的char
// -128 ~ 127

// 无符号的char
// 0 ~ 255
// char默认是有符号的 signed char

// #include <stdio.h>
// int main() {
//     //补码截断存储
//     char a = -1;
//     // 10000000 00000000 00000000 00000001 源码
//     // 11111111 11111111 11111111 11111111 补码
//     //补码截断存储  // 11111111

//     // 打印 先进行行整形提升 补符号位
//     // 11111111 11111111 11111111 11111111 补码
//     // 10000000 00000000 00000000 00000001 源码 打印输出 -1 
//     signed char b = -1; //同上

//     unsigned char c = -1;
//     // 10000000 00000000 00000000 00000001 源码
//     // 11111111 11111111 11111111 11111111 补码
//     //补码截断存储  // 11111111

//     // 打印 先进行行整形提升
//     //无符号整形提升，高位补0
//     // 整形提升是看原来的类型
//     // 00000000 00000000 00000000 11111111 补码 前面的符号位变成正数了 所以源码 反码 补码相同了
//     // 00000000 00000000 00000000 11111111 源码 //255

//     printf("a=%d b=%d c=%d", a, b, c);
//     // a=-1 b=-1 c=255
//     return 0;
// }

// #include <stdio.h>
// int main() {
//     char a = 128;
//     //128 二进制 00000000 00000000 00000000 10000000
//     //  10000000 -a

//     //整形提升 (看原类型)
//     // 11111111 11111111 11111111 10000000 补码
//     //打印时是 无符号整型(没有负数的定义)
//     //补码源码相同 // 11111111 11111111 11111111 10000000 源码
//     // 输出4,294,967,168
//     printf("a=%u\n", a);
//     return 0;
// }

// #include <stdio.h>
// int main() {
//     int i = -20;
//     // 10000000 00000000 00000000 00010100 源码
//     // 11111111 11111111 11111111 11101100 补码

//     unsigned int j = 10;
    //00000000 00000000 00000000 00001010 源码
    //00000000 00000000 00000000 00001010 补码相同

    //i + j
    //补码相加
    // 11111111 11111111 11111111 11101100 -i
    // 00000000 00000000 00000000 00001010 -j

    // 11111111 11111111 11111111 11110110 i + j补码
    // 符号位不变其他位按位取反 + 1
    // 10000000 00000000 00000000 00001010 源码 -> -10

//     printf("%d\n", i + j);  //-10
//     return 0;
// }

// #include <stdio.h>
// #include <string.h>
// int main() {

//     char a[1000];
//     int i = 0;

//     for (i = 0; i < 1000; i++) {
//         a[i] = -1 - i;
//     }
//     //char -128 ~ 127
//     // 补码

//     //正                  //负
//     // 0000 0000 0         1111 1111 -1
//     // 0000 0001 1         1111 1110 -2
//     // 0000 0010 2         .... .... .  
//     // .... .... .         .... .... .  
//     // 0111 1111 127       1000 0000 -128

//     //减一
//     // -1 -2 -3 .... -128 127 126 .... 0 -1 -2...
//     // 127 + 128 = 255 

//     //0之前有多少个数字 //255
//     printf("%d", strlen(a));
// }


// #include <stdio.h>
// unsigned char i = 0;
// int main() {

//     for (i = 0; i <= 255; i++) {
//         printf("hello world\n");
//     }
//     //临界时 255 + 1 又变成0了

//         //正       
//     // 0000 0000 0
//     // 0000 0001 1
//     // 0000 0010 2
//     // .... .... .  
//     // 0111 1111 127
//     // .............
//     // 1111 1110 254
//     // 1111 1111 255

//     // 0 1 ... 127 -128 -127 ... -2 -1
//     return 0;

// }

// -------------------浮点数存储规则-----------------


// 根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的形式：(-1)^S* M * 2^E
// （—1)^S表示符号位，当S=0，V为正数；当S=1,v为负数。

// ·M表示有效数字，大于等于1，小于2。

// ·2^E表示指数位

// 二进制的科学计数法
// v = 5.0f; 将5转换成二进制
// 101.0 --> 1.01 * 2^2 --> (-1)^0 * 1.01 *  2^2

//小数点后一位的权重是2^(-1)
// v = 9.5f ---> 1001.1 ---> 1.0011 * 2^3 ----> (-1)^0 * 1.0011 * 2^3

// 内存中存储的是S M E 的值存储
// [S(1bit)] [  E(8bit)  ] [      M(23bit)       ] 

// float f = 5.5;
// 5.5
// 101.1
// 1.011 * 2^2
// s=0 e=2 m=1.011
// m中的1不放
// 存储e值(存储的是unsigned int)的时候要加上中间值再进行存储 单精度浮点+127 双精度浮点+1023
// 0 10000001 01100000000000000000000
// 0100 0000 1011 0000 0000 0000 0000 0000
// 4    0    b    0    0    0    0    0 十六进制
// 0x40 b0 00 00 

// #include <stdio.h>
// int main() {
//     float f = 5.5;
//     printf("%p\n", f);

//     return 0;
// }

// -------------------浮点数取出规则-----------------
// E不为全0或者不为全1：

// 这时，浮点数就采用下面的规则表示，
// 即指数E的计算值减去127（或1023），得到真实值，
// 再将有效数字M前加上第一位的1。

// E全为0

// 这时，浮点数的指数E等于1—127（或者1—1023）即为真实值，
// 有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。
// 这样做是为了表示±0，以及接近于0的很小的数字。

// E全为1

// 这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）


// -------------------指针进阶-----------------

// -------------------字符指针-----------------
// #include <stdio.h>
// int main() {
//     char* p = "abcdef";//p中存放了a的地址
//     char* p2 = "abcdef";

//     printf("%s\n", p);  //%s打印提供地址就可以了

//     if (p == p2) {
//         printf("p==p2");
//     }
//     return 0;
// }

// 常量字符串(在内存的只读区)具有唯一性


// -------------------指针数组-----------------
// 指针数组是数组 是用来存放指针的数组
// #include <stdio.h>
// int main() {
//     int arr1[] = {1,2,3,4};
//     int arr2[] = {3,4,5,6};
//     int arr3[] = {5,6,7,8};

//     int* arrp[3] = {arr1, arr2, arr3};

//     int i = 0;
//     for (i = 0; i < 3; i++) {
//         int j = 0;
//         for (j = 0; j < 4; j++) {
//             printf("%d ", *(arrp[i] + j));
//         }
//         printf("\n");
//     }
//     return 0;
// }

// -------------------数组指针-----------------

// 数组指针 -指针 —指向数组的指针

// 整型指针—指向整型的指针
// int*

// 字符指针—指向字符的指针

//运算优先级[]最高
// int *p1[10]     p1优先和[]结合 是int* 类型的指针 是指针数组

// int (*p2)[10]       p2优先和*结合 p2是指针   是数组指针
// p2是数组指针，p2可以指向一个数组，该数组有10个元素，每个元素是int类型

// 数组名：表示第一个元素的地址、表示整个数组

// 数组名
// 数组名确实能表示首元素的地址
// 有两个例外
// 1.sizeof(arr)     这里表示整个数组
// 2.&数组名      这里的数组名表示整个数组的地址，取出的是整个数组的地址
// #include <stdio.h>
// int main() {
//     // int arr[10] = {0};
//     // int* p = arr;
//     // //类型是int(*)[10]
//     // int (*p2)[10] = &arr;//[10]表示指向的元素

//     // char* arr[5] = {0};
//     // char* (*pc)[5] = &arr; 

//     return 0;
// }

// 数组指针比较常用于二维或高维数组
// #include <stdio.h>
// void print1(int (*p)[5], int r, int c) {
//     int i = 0;
//     for (i = 0; i < r; i++) {
//         //拿到了第i行的地址,解引用得到了每一个数组元素(相当于数组名),
//         //数组名又代表了二维数组的/数组元素/的首元素地址
//         // *(p + i) //arr1 arr2 arr3
//         int j = 0;
//         for (j = 0; j < c; j++) {
//             printf("%d ", *(*(p + i) + j));
//             // 相当于
//             //p是首元素地址,所以相当于二维数组名,所以[i]即为二维数组第i行
//             printf("%d ", p[i][j]);
//         }
//         printf("\n");
//     }

// }

// int main() {
//     int arr[3][5] = {1,2,3,4,5,2,3,4,5,6,3,4,5,6,7};

//     // 二维数组名是首元素，是第一行的地址
//     // arr表示第一行的地址，即一维数组的地址，现在就是用数组指针来接收这个一维数组的地址
//     // 应该是不能&后放入,否则是整个二维数组
//     print1(arr, 3, 5);

//     return 0;
// }

// int arr[5]              整型数组

// int *parr1[10]          指针数组
// int *parr1[10] 的类型是 int *[10]

// int (*parr2)[10]        数组指针
// parr2拿去   int (*)[10] 为类型名称

// int (*parr3[10])[5]     所以是  存放数组指针的数组
// parr3[10]  []优先级高先结合 变量是parr3的10个元素 每一个的类型即为数组指针
// int (*)[5]  为类型()

// 指针数组指针
// #include <stdio.h>

// int main() {
//     int a = 10, b = 20, c = 30;

//     // 1. 定义一个指针数组，里面放的是指向 int 的指针
//     int *arr[3] = { &a, &b, &c };

//     // 2. 定义一个指针，指向这个指针数组
//     // 其类型是：
//     int *(*p)[3] = &arr;

//     // 3. 访问数组中的元素
//     for (int i = 0; i < 3; i++) {
//         printf("Value: %d\n", *(*p)[i]);
//     }

//     return 0;
// }
// *什么   说明这个变量是指针
// *什么[] 括号优先   说明这个是数组

// 二级指针是专门用来存放一级指针变量的地址的
// 二维数组传参的方法就是数组指针


// -------------------函数指针-----------------
// 数组指针 - 指向数组的指针
// 函数指针 - 指向函数的指针

// #include <stdio.h>
// int add(int x, int y) {
//     return x + y;
// }
// int main() {
//     int arr[10] = {0};
//     //&arr 取出数组的地址
//     int (*p)[10] = &arr;

//     printf("%p\n", add);
//     printf("%p\n", &add);
//     //对于函数来说 &函数名和函数名都是函数的地址

//     int (*p_add)(int, int) = &add;
//     int ret = (*p_add)(2, 3);
//     //一样的,p_add代表地址相当于函数名
//     // int ret = p_add(2, 3);
//     printf("%d\n", ret);
//     return 0;
// }

// []最高
// ()第二

// ( *( void (*)() )0 )()        

//以上代码是一次函数调用,调用的是0作为地址的函数
// void (*)() 函数指针类型
// ( void (*)() )0      0是int 强制类型转换为 函数指针类型
//解引用得到函数 并且进行函数传参调用(无参数)       (*(函数指针类型)0)()


// void (* signal(int, void(*)(int) ))(int); 

//以上代码是一次函数声明
// signal  函数名
// (int, void(*)(int) )    声明函数需要传递的参数是int 和 函数指针类型 这里并不是传参
// void (*)(int);      剩下的是signal函数的返回类型        是函数指针类型


// typedef void(* pf_t)(int);
// int main() {
//     void (* signal(int, void(*)(int) ))(int);
//     //上下效果一样
//     pf_t signal(int, pf_t);

//     return 0;
// }

//函数指针的用途

//计算器
// #include <stdio.h>
// void menu() {
//     printf("******************************\n");
//     printf("*****    1. 加  2. 减    *****\n");
//     printf("*****    3. 乘  4. 除    *****\n");
//     printf("********    0.退出    ********\n");
//     printf("******************************\n");

// }

// int Add(int x, int y) {
//     return x + y;
// }

// int Sub(int x, int y) {
//     return x - y;
// }

// int Mul(int x, int y) {
//     return x * y;
// }

// int Div(int x, int y) {
//     return x / y;
// }

//回调函数
// //计算
// void calc(int (*p_func) (int, int)) {
//     int x = 0;
//     int y = 0;
//     int ret = 0;

//     printf("请输入两个数>");
//     scanf("%d %d", &x, &y);

//     ret = p_func(x, y);
//     printf("%d\n", ret);

// }
// int main() {
//     int input = 0;


//     do {
//         menu();
//         printf("请选择>");
//         scanf("%d", &input);
        
//         switch (input) {
//             case 1:
//                 calc(Add);
//                 break;
//             case 2:
//                 calc(Sub);
//                 break;
//             case 3:
//                 calc(Mul);
//                 break;
//             case 4:
//                 calc(Div);
//                 break;
//             case 0:
//                 printf("退出计算器\n");
//                 break;
//             default:
//                 printf("选择错误");
//                 break;
//         }
//     }while (input);

//     return 0;
// }


// -------------------函数指针数组-----------------
// #include <stdio.h>

// int Add(int x, int y) {
//     return x + y;
// }

// int Sub(int x, int y) {
//     return x - y;
// }

// int Mul(int x, int y) {
//     return x * y;
// }

// int Div(int x, int y) {
//     return x / y;
// }

// int main() {
//     //写法
//     int (*arr[4])(int, int) = {Add, Sub, Mul, Div};

//     int i = 0;
//     int ret = 0;
//     for (i = 0; i < 4; i++) {
//         ret = arr[i](8, 4);
//         printf("%d\n", ret);
//     }
//     return 0;
// }


// -------------------指向函数指针数组的指针-----------------
    // 指向函数指针数组的指针是一个指针
    // 指针指向一个数组，数组的元素都是函数指针

// #include <stdio.h>
// int main() {
//     //函数指针数组
//     int (*pf_arr[5])(int, int) = {0, Add, Sub, Mul, Div};

//     // 指向函数指针数组的指针
//     int (*(*p_pf_arr)[5]) (int, int) = &pf_arr;

//     return 0;
// }

// -------------------回调函数----------------
//冒泡排序

#include <stdio.h>
void bubble_sort(int arr[], int sz) {
    int i = 0;
    //总次数
    for (i = 0; i < sz - 1; i++) {
        int flag = 1; //假设数组排好序

        //一趟排序
        int j = 0;
        for (j = 0; j < sz - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;

                flag = 0; //有交换一次说明不是有序
            }
        }
        if (flag == 1) {
            break;
        }
    }
}
int main() {
    int arr[] = {9,8,7,6,5,4,3,2,1,0};
    int sz = sizeof(arr) / sizeof(arr[0]);

    bubble_sort(arr, sz);

    int i = 0;
    for (i = 0; i < sz; i++) {
        printf("%d ", arr[i]);
    }

    return 0;
}
