// -------------------数据存储-----------------

//整数的2进制表示也有三种表示形式：

//1.正的整数，原码、反码、补码相同
//2.负的整数，原码、反码、补码是需要计算的
//原码：直接通过正负的形式写出的二进制序列就是原码
//反码：原码的符号位不变，其他位按位取法得到的就是反码
//补码：反码+1就是补码


//  高位      低位
// 0x11 22 33 44
// ---------------------------------------->
// 地地址                              高地址

// 大端【字节序】存储：
// 把一个数据的高位字节序的内容存放在低地址处，把低位字节序的内容放在高地址处，就是大端字节序存储。

// 小端【字节序】存储：
// 把一个数据的高位字节序的内容存放在高地址处，把低位字节序的内容放在低地址处，就是小端字节序存储。

//判断设备存放数据模式(大小端)
// #include <stdio.h>
// int check_sys() {
//     int a = 1;
//     //0x00 00 00 01

//     //01 00 00 00
//     //0000 0001
//     char* p = (char*)&a;
//     if (*p == 1) {
//         return 1;
//     }
//     else {
//         return 0;
//     }
// }
// int main() {
//     int ret = check_sys();
//     if (ret == 1) {
//         printf("小端存储\n");
//     }
//     else {
//         printf("大端存储\n");
//     }
//     return 0;
// }


// -------------------整型提升-----------------
// 补码中进行

// 负数的整形提升
// char c1=-1;
// 变量c1的二进制位（补码）中只有8个比特位：1111111
// 因为 char 为有符号的char
// 所以整形提升的时候，高位补充符号位，即为1提升之后的结果是：
// 11111111111111111111111111111111 

//正数的整形提升
// char c2 1;
// 变量c2的二进制位（补码）中只有8个比特位：00000001
// 因为 char 为有符号的 char
// 所以整形提升的时候，高位补充符号位，即为0提升之后的结果是：
// 0000000000000000000000000001 

//无符号整形提升，高位补0

// #include <stdio.h>
// int main() {
//     char a = 5;
//     // 补码截断存储:
//     // 00000101

//     char b = 125;
//     // 补码截断存储:
//     // 01111101

//     char c = a + b;
//     //计算时整型提升
//     //补符号位
//     // 00000000 00000000 00000000 00000101 - a
//     // 00000000 00000000 00000000 01111101 - b
//     // 相加
//     // 00000000 00000000 00000000 10000011 - c
//     //截断存储  这里是负数，所以对应补码
//     // 10000011 - c
//     //负数
//     //打印出整数也要进行整形提升
//     //补符号位
//     // 11111111 11111111 11111111 10000011 - c 补码
//     //按位取反 + 1
//     // 10000000 00000000 00000000 01111101 - c 源码 //-125

//     printf("%d\n", c);
//     return 0;
// }

// #include <stdio.h>
// int main() {
//     char a = 0xb6;
//     short b = 0xb600;
//     int c = 0xb6000000;


//     //只打印a 表达式中会发生整型提升
//     if (a == 0xb6) {
//         printf("a\n");
//     }

//     if (b == 0xb60) {
//         printf("b\n");
//     }

//     if (c == 0xb6000000) {
//         printf("c\n");
//     }
//     return 0;
// }

// -------------------算数转换-----------------
// 向上转换
// long double
// double
// float
// unsigned long int
// long int
// unsigned int
// int

// 有符号的char
// -128 ~ 127

// 无符号的char
// 0 ~ 255
// char默认是有符号的 signed char

// #include <stdio.h>
// int main() {
//     //补码截断存储
//     char a = -1;
//     // 10000000 00000000 00000000 00000001 源码
//     // 11111111 11111111 11111111 11111111 补码
//     //补码截断存储  // 11111111

//     // 打印 先进行行整形提升 补符号位
//     // 11111111 11111111 11111111 11111111 补码
//     // 10000000 00000000 00000000 00000001 源码 打印输出 -1 
//     signed char b = -1; //同上

//     unsigned char c = -1;
//     // 10000000 00000000 00000000 00000001 源码
//     // 11111111 11111111 11111111 11111111 补码
//     //补码截断存储  // 11111111

//     // 打印 先进行行整形提升
//     //无符号整形提升，高位补0
//     // 整形提升是看原来的类型
//     // 00000000 00000000 00000000 11111111 补码 前面的符号位变成正数了 所以源码 反码 补码相同了
//     // 00000000 00000000 00000000 11111111 源码 //255

//     printf("a=%d b=%d c=%d", a, b, c);
//     // a=-1 b=-1 c=255
//     return 0;
// }

// #include <stdio.h>
// int main() {
//     char a = 128;
//     //128 二进制 00000000 00000000 00000000 10000000
//     //  10000000 -a

//     //整形提升 (看原类型)
//     // 11111111 11111111 11111111 10000000 补码
//     //打印时是 无符号整型(没有负数的定义)
//     //补码源码相同 // 11111111 11111111 11111111 10000000 源码
//     // 输出4,294,967,168
//     printf("a=%u\n", a);
//     return 0;
// }

// #include <stdio.h>
// int main() {
//     int i = -20;
//     // 10000000 00000000 00000000 00010100 源码
//     // 11111111 11111111 11111111 11101100 补码

//     unsigned int j = 10;
    //00000000 00000000 00000000 00001010 源码
    //00000000 00000000 00000000 00001010 补码相同

    //i + j
    //补码相加
    // 11111111 11111111 11111111 11101100 -i
    // 00000000 00000000 00000000 00001010 -j

    // 11111111 11111111 11111111 11110110 i + j补码
    // 符号位不变其他位按位取反 + 1
    // 10000000 00000000 00000000 00001010 源码 -> -10

//     printf("%d\n", i + j);  //-10
//     return 0;
// }


