// -----------------------时间复杂度---------------------
// 2.2 大 O 的渐进表示法
// 大 O 符号（Big O notation）：是用于描述函数渐进行为的数学符号。
// 推导大 O 阶方法：
// 1、用常数 1 取代运行时间中的所有加法常数。
// 2、在修改后的运行次数函数中，只保留最高阶项。
// 3、如果最高阶项存在且不是 1，则去除与这个项目相乘的常数，得到的结果就是大 O 阶。

// 计算Func4的时间复杂度？  复杂度为O(1)
// void Func4(int N)
// {
//     int count = 0;
//     for (int k = 0; k < 100; ++ k)
//     {
//         ++count;
//     }
//     printf("%d\n", count);
// }

// 当一个算法随着输入不同，时间复杂度不同，时间复杂度做悲观预期，看最坏的情况

// 二分查找
// 一个数组    元素个数N
// 查找一次得到N/2
// 最坏的情况 N/2/2/2/2... = 1 (找到了)    (假设查找了X次)
// N / (2^X) = 1
// 由此得到时间复杂度为 X = log N (2为底)

// 递归算法：递归次数*每次递归调用的次数


// 计算斐波那契递归Fib的时间复杂度？    复杂度O(2^N)
// long long Fib(size_t N)
// {
//     if(N < 3)
//         return 1;

//     return Fib(N-1) + Fib(N-2);
// }


// -----------------------空间复杂度---------------------
// 空间复杂度也是一个数学函数表达式，是对一个算法在运行过程中临时占用存储空间大小的量度。
// 空间复杂度不是程序占用了多少 bytes 的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。
// 空间复杂度计算规则基本跟时间复杂度类似，也使用大 O 渐进表示法。
// 注意：函数运行时所需要的栈空间 (存储参数、局部变量、一些寄存器信息等) 在编译期间已经确定好了，
// 因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。(变量开辟内存的个数)

// 空间可以重复利用，时间是累计的