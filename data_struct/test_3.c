// 节点的度：一个节点含有的子树的个数称为该节点的度；如上图：A 的为 6 
// 叶节点或终端节点：度为 0 的节点称为叶节点；如上图：B、C、H、I… 等节点为叶节点 
// 非终端节点或分支节点：度不为 0 的节点；如上图：D、E、F、G… 等节点为分支节点
// 双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；如上图：A 是 B 的父节点
// 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；如上图：B 是 A 的孩子节点 
// 兄弟节点：具有相同父节点的节点互称为兄弟节点；如上图：B、C 是兄弟节点 
// 树的度：一棵树中，最大的节点的度称为树的度；如上图：树的度为 6
// 节点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推；
// 树的高度或深度：树中节点的最大层次；如上图：树的高度为 4 


// 完全二叉树:
// 前 k - 1 层都是满的，最后可以不满
// 必须左到右连续

// 树
// 二叉树
// 完全二叉树
// 满二叉树

// 若规定根节点的层数为 1，则一棵非空二叉树的第 i 层上最多有 2^(i - 1) 个结点.
// 若规定根节点的层数为 1，则深度为 h 的二叉树的最大结点数是 2^h - 1(总的节点数)
// 对任何一棵二叉树，如果度为 0 其叶结点个数为 n0，度为 2 的分支结点个数为 n2，则有 n0 = n2 + 1

// 完全二叉树:
// 度为0的节点 x
// 度为2的节点 x - 1
// 度为1的节点 只能是1或者0

// 所以x + x - 1 (加1或者0) = 总的节点数

    // 满二叉树有 n 个节点，那它的深度 d 为：
    // d=log 2 (n + 1)

    // 完全二叉树的深度
    // d=⌊log 2(n)⌋+1

// ----------------------------------堆-----------------------------
// 大堆：
// 1、完全二叉树
// 2、每个父亲都大于等于孩子

// 小堆：
// 1、完全二叉树
// 2、每个父亲都小等于孩子

// 选数
// 大堆特点：根 (堆顶) 就是最大值
// 选数
// 大堆特点：根 (堆顶) 就是最大值

// 父节点下标：parent(i) = (i - 1) / 2
// 左孩子下标：left(i) = 2 * i + 1
// 右孩子下标：right(i) = 2 * i + 2

//向下调整算法
// void Swap(HpDataType* e1, HpDataType* e2) {
//     HpDataType tmp = *e1;
//     *e1 = *e2;
//     *e2 = tmp;
// }

// void adjust(HpDataType* a, int n, int root) {
//     int parent = root;
//     int child = parent * 2 + 1; 
//     //找出最小的孩子
//     while (child < n) {
//         if (child + 1 < n && [child + 1] < a[child]) {
//             ++child;
//         }
//         //如果孩子小于父亲就交换,大于就说明完成
//         if (a[child] < a[parent]) {
//             Swap(&a[child], &a[parent]);
//             parent = child;
//             child = parent * 2 + 1;
//         }
//         else {
//             break;
//         }
//     }
// }

// 小堆选出最小的，和数组的最后的值进行互换，然后再次建堆，数据个数为n - 1，就可以选出次小的值
// 排完序就可以得到降序的数组，排升序相反就可以采用大堆，时间复杂度为 N * logN

// 排列升序：使用大堆
// 排列降序：使用小堆


