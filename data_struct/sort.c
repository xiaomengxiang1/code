// ----------------------------------排序-----------------------------


// 排序算法	时间复杂度（平均）	空间复杂度	        稳定性	            思想简述

// 冒泡排序	O(n²)	            O(1)	         ✅ 稳定	        相邻交换，最大向后冒

// 选择排序	O(n²)	            O(1)	         ❌ 不稳定	    每轮选最小放前面

// 插入排序	O(n²)	            O(1)	         ✅ 稳定	        类似抓扑克牌那样插入

// 希尔排序	O(n^1.3~n^2)	    O(1)	         ❌ 不稳定	    插入排序的跳跃加强版

// 快速排序	O(nlogn)	        O(logn)	         ❌ 不稳定	    分治 + 基准点划分

// 归并排序	O(nlogn)	        O(n)	         ✅ 稳定	        分治 + 有序合并

// 堆排序	O(nlogn)	        O(1)	         ❌ 不稳定	    构建堆 + 每次取最大

// 912. 排序数组
// https://leetcode.cn/problems/sort-an-array/description/


// ✅ 1. 插入排序（InsertSort）
// 核心思路：
// 把数据看作两部分：已排序 + 未排序。
// 每次将一个“未排序”的元素插入到前面“已排序”的部分，使之有序。

// 过程描述：
// 像打扑克牌插牌一样，一个一个插入到合适位置。

// 时间复杂度： 最坏 $O(n^2)$
// 适用场景： 数据量小、基本有序的数组。

// ✅ 2. 希尔排序（ShellSort）
// 核心思路：
// 对插入排序的改进，先分组进行“预排序”，再逐渐缩小 gap，最后变成普通插入排序。

// 过程描述：
// 初始 gap = n/2，逐渐减小，组内进行插入排序。

// 时间复杂度： 视 gap 而定，最坏 $O(n^2)$，常见 $O(n^{1.3})$
// 适用场景： 中小数据集优化插入排序性能。

// ✅ 3. 选择排序（SelectSort）
// 核心思路：
// 每次从无序区中选择最小（或最大）值放到已排序区末尾。

// 过程描述：
// 找最小值交换，n 次找到 n 个最小值。

// 时间复杂度： 始终 $O(n^2)$
// 适用场景： 简单直接，适合教学演示，实际不常用。

// ✅ 4. 堆排序（HeapSort）+ 调整函数（AdjustDown）
// 核心思路：
// 利用堆结构（通常是大堆），每次将堆顶（最大值）取出，重新调整堆。

// 过程描述：

// 建堆（从最后一个非叶子节点向下调整）

// 依次将堆顶元素交换到末尾，重新调整堆

// 时间复杂度： $O(n \log n)$，不稳定排序
// 适用场景： 需要原地、非递归、对空间敏感的排序。

// ✅ 5. 冒泡排序（BubbleSort）
// 核心思路：
// 相邻元素两两比较，较大值逐渐“冒泡”到后面。

// 过程描述：
// 每轮把当前最大值交换到数组末尾。

// 时间复杂度： 最坏 $O(n^2)$，可以优化
// 适用场景： 教学展示，小数据，思路简单。

// ✅ 6. 快速排序（QuickSort）+ 非递归版本
// 核心思路：
// 分治法——选一个基准，将数组划分为两部分（小于基准/大于基准），递归处理。

// 过程描述：

// 选 pivot（基准）
// 进行一次分区
// 对左右区间递归快排

// 非递归版本：
// 用栈模拟递归过程。

// 时间复杂度：
// 平均 $O(n \log n)$
// 最坏 $O(n^2)$（选不好 pivot）
// 适用场景： 快速、效率高，是实际使用最广泛的排序之一。

// ✅ 7. 归并排序（MergeSort）+ 非递归版本
// 核心思路：
// 分治法——不断二分，排序后合并两个有序段。

// 过程描述：
// 拆分数组直到单个元素
// 递归合并回去

// 非递归版本：
// 底层从小段开始合并，逐渐扩大段长度（类似完全二叉树层次）
// 时间复杂度： 稳定 $O(n \log n)$，稳定排序

// 适用场景：
// 大规模排序，需要稳定性时推荐。

// ✅ 8. 外部归并排序（MergeSortFile）
// 核心思路：
// 当数据量过大（如1000亿）无法一次读入内存，采用外部排序。

// 过程描述：
// 把数据切成小块，分别排序（放磁盘）
// 多路归并这些文件（通常用堆维护最小值）

// 适用场景：
// 超大文件、内存有限的场景，如数据库、日志排序等。

// ✅ 9. 计数排序（CountSort）
// 核心思路：
// 对每个元素计数，通过计数数组来确定每个元素位置。

// 过程描述：
// 找最大最小值，开计数桶
// 遍历统计每个元素出现次数
// 重建有序数组

// 时间复杂度：
// $O(n + range)$
// 要求整数，值域不能太大
// 适用场景：
// 元素值域有限

// 如：考试分数统计（0～100）